    processor 6502

;; <---- Include files that contain memory addresses and macros ---->

    include "vcs.h"
    include "macro.h"

;; <---- Declare variables starting from memory address $80 ---->

    seg.u Variables
    ORG $80

BirdXPosition                           byte    ; bird X position
BirdYPosition                           byte    ; bird Y position
BirdYVelocity                           byte    ; bird vertical velocity
Pipe1XPosition                          byte    ; pipe 1 X position
Pipe2XPosition                          byte    ; pipe 2 X position
Pipe1VerticalGapStartPosition           byte    ; Y position where pipe 1 vertical gap starts
Pipe2VerticalGapStartPosition           byte    ; Y position where pipe 2 vertical gap starts
Pipe1VerticalGapEndPosition             byte    ; Y position where pipe 1 vertical gap ends
Pipe2VerticalGapEndPosition             byte    ; Y position where pipe 2 vertical gap ends
SkyColor                                byte    ; background sky color
GrassColor                              byte    ; playfield grass color
GroundColor                             byte    ; playfield ground color
PipesColor                              byte    ; pipes color
ScoreColor                              byte    ; score digits color
GameState                               byte    ; game state. 0 - start, 1 - game started, 2 - game over
Score                                   word    ; score (ones and tens are stored in Score+1 and hundreds and thousands in Score)
OnesDigitOffset                         word    ; lookup table offset for the score 1's digit, OnesDigitOffset = Score, OnesDigitOffset+1 = Score+1
TensDigitOffset                         word    ; lookup table offset for the score 10's digit, TensDigitOffset = Score, TensDigitOffset+1 = Score+1
RemainingScoreLines                     byte    ; counter for remaining scanlines for score
ButtonDebounce                          byte    ; stores the value of INPT4 to check if button is still pressed in the next frame
RandomNumber                            byte    ; an initial random seed and a random number generated by GenerateRandomNumber subroutine
Temp                                    byte    ; a variable to store temporary/intermediate values

;; <---- Define constants ---->

BIRD_HEIGHT = 11
BIRD_JUMP_SPEED = 7
BIRD_FALLING_SPEED = 1
BIRD_FLOAT_MAX_POSITION = 75
BIRD_FLOAT_MIN_POSITION = 55
BIRD_MIN_Y_POSITION = 0
BIRD_MAX_Y_POSITION = 142
VERTICAL_GAP_BETWEEN_PIPES = 60
LEFT_BORDER = -1
RIGHT_BORDER = 136
SCORE_DIGITS_HEIGHT = 5
GAME_STATE_START = 0
GAME_STATE_ACTIVE = 1
GAME_STATE_OVER = 2

;; <---- Start ROM code at memory address $F000 ---->

    seg Code
    ORG $F000

Reset:
    CLEAN_START     ; reset memory and registers

;; <---- Initialization ---->

    LDA INTIM
    STA RandomNumber                ; seed random number with value at INTIM address

    LDA #$9A
    STA SkyColor

    LDA #$C6
    STA GrassColor

    STA PipesColor

    LDA #$FE
    STA GroundColor

    LDA PipesColor
    STA COLUP1

    JSR ResetGame

    LDA #$30
    STA NUSIZ1                      ; set missile 1 (pipe 1) width

Frame:
;; <---- Display VSYNC and VBLANK and perform calculations before displaying visible scanlines ---->

    LDA #2
    STA VBLANK                      ; enable VBLANK
    STA VSYNC                       ; enable VSYNC
    REPEAT 3
        STA WSYNC                   ; display 3 VSYNC lines
    REPEND
    LDA #0
    STA VSYNC                       ; disable VSYNC

    LDX #28                         ; set counter for 37 - 9 VBLANK scanlines (9 scanlines are always used during calculations in VBLANK)

    LDA #1
    STA CTRLPF                      ; enable playfield reflection (for score)

    JSR GenerateRandomNumber

    STA WSYNC

    LDA GameState
    CMP #GAME_STATE_START
    BNE .ProcessNewPipePositions

;; Bird initial float animation before game start
.BirdFloat:
    LDA BirdYPosition
    CMP #BIRD_FLOAT_MAX_POSITION
    BEQ .NegativeVelocity
    CMP #BIRD_FLOAT_MIN_POSITION
    BEQ .PositiveVelocity
    JMP .ApplyFloatVelocity
.PositiveVelocity:
    LDY #1
    STY BirdYVelocity
    JMP .ApplyFloatVelocity
.NegativeVelocity:
    LDY #-1
    STY BirdYVelocity
.ApplyFloatVelocity:
    CLC
    ADC BirdYVelocity
    STA BirdYPosition

    JMP .SetObjectsXPositions

    
.ProcessNewPipePositions:
    LDY #0
    JSR ProcessNewPipePosition

    STA WSYNC

    LDY #1
    JSR ProcessNewPipePosition

.ApplyBirdVerticalVelocity:
    STA WSYNC
  
    LDA BirdYPosition
    CMP #BIRD_MIN_Y_POSITION
    BEQ .SetObjectsXPositions
    CLC
    ADC BirdYVelocity
    TAY
    LDA #%10000000
    BIT BirdYPosition                               ; the bird Y position will be negative when it is > 127 because of two's complement, which can break the logic of checking/adjusting min position
    BNE .CheckAndAdjustBirdMaxPosition              ; as it impossible for the bird to reach the min position at this point, the corresponding check is skipped in this case 
    BIT BirdYVelocity
    BEQ .CheckAndAdjustBirdMaxPosition              ; the max position should be checked only if birds has positive velocity (which means that it is going upwards)
.CheckAndAdjustBirdMinPosition:
    CPY #BIRD_MIN_Y_POSITION
    BPL .StoreNewBirdYPosition
    LDY #BIRD_MIN_Y_POSITION
    JMP .StoreNewBirdYPosition
.CheckAndAdjustBirdMaxPosition:
    CPY #BIRD_MAX_Y_POSITION
    BMI .StoreNewBirdYPosition
    LDY #BIRD_MAX_Y_POSITION
.StoreNewBirdYPosition:
    STY BirdYPosition
.ApplyBirdFallingSpeed:
    LDA BirdYVelocity
    SEC
    SBC #BIRD_FALLING_SPEED
    STA BirdYVelocity
    
.SetObjectsXPositions:
    LDA BirdXPosition
    LDY #0
    JSR SetObjectXPosition                          ; set player 0 (bird) horizontal position

    LDA Pipe1XPosition
    LDY #3
    JSR SetObjectXPosition                          ; set missile 1 (that represents the first pipe) horizontal position

    STA WSYNC

    LDA Pipe2XPosition
    LDY #1
    JSR SetObjectXPosition                          ; set player 1 (that represents the second pipe) horizontal position

    STA WSYNC
    STA HMOVE

    JSR CalculateDigitOffset

    LDA ScoreColor            
    STA COLUPF  

.RemainingVBLANKScanline:
    DEX
    STA WSYNC
    BNE .RemainingVBLANKScanline

    LDA #0
    STA VBLANK      ; disable VBLANK


;; <---- Display 192 visible scanlines ---->

    LDA #SCORE_DIGITS_HEIGHT
    STA RemainingScoreLines         ; set counter for score scanlines
		
    LDY TensDigitOffset             ; get the tens digit offset for the Score
    LDA ReversedDigits,Y            ; use it to load the digit graphics
    AND #$0F                        ; remove the graphics for the ones digit
    STA Temp                        ; save it to the Temp variable

.ScoreLoop:            
    LDY OnesDigitOffset             ; get the ones digit offset for the Score
    LDA ReversedDigits,Y            ; use it to load the digit graphics
    AND #$F0                        ; remove the graphics for the tens digit
    ORA Temp                        ; merge with the tens digit graphics
    TAX                             ; save in X for later		
    STA WSYNC                       ; wait for end of scanline
  
    STX PF2                         ; update PF2 for left side of screen
    LDY OnesDigitOffset+1           ; get the left digit offset for the Score+1
    LDA Digits,Y                    ; use it to load the digit graphics
    AND #$0F                        ; remove the graphics for the ones digit
    STA Temp                        ; and save it
    LDY TensDigitOffset+1           ; get the ones digit offset for the Score+1
    LDA Digits,Y                    ; use it to load the digit graphics
    AND #$F0                        ; remove the graphics for the tens digit
    ORA Temp                        ; merge with the tens digit graphics
    JSR Sleep12Cycles
    SLEEP 6                
    STA PF2                         ; update PF2 for right side of screen
    STA WSYNC                       ; wait for end of scanline		

    STX PF2                         ; update PF2 for left side of screen
    TAX                             ; save in X for right side
    INC OnesDigitOffset             ; advance for the next line of graphic data
    INC OnesDigitOffset+1           ; advance for the next line of graphic data
    INC TensDigitOffset             ; advance for the next line of graphic data
    INC TensDigitOffset+1           ; advance for the next line of graphic data
    LDY TensDigitOffset             ; get the tens digit offset for the Score
    LDA ReversedDigits,y            ; use it to load the digit graphics
    AND #$0F                        ; remove the graphics for the ones digit
    STA Temp                        ; and save it
    DEC RemainingScoreLines         ; decrement score loop counter
    SLEEP 3                         
    STX PF2                         
    BNE .ScoreLoop                  ; if RemainingScoreLines != 0 then branch to ScoreLoop

    STA WSYNC                       ; wait for end of scanline

    LDA #0
    STA PF0
    STA PF1
    STA PF2
    STA COLUPF
    STA WSYNC

;; Set horizontal padding using the playfield so there would be time to regenerate and reset vertical gaps between pipes when they go off screen
    LDA #%00000101       
    STA CTRLPF              ; bit 0 - set playfield to be reflected; bit 2 - playfield priority over players and missiles so pipes would be able to go offscreen; bits 4 and 5 - ball (pipe 2) width

    LDA #%11110000       
    STA PF0                 ; set padding by using the playfield register PF0

    STA WSYNC

    LDX #152                ; set counter for remaining visible scanlines to the X register (152 because 25 are used for the static playfield and 15 for score)

    LDA SkyColor            ; preload the sky color

    STA WSYNC

VisibleScanline:
    STA COLUBK              ; set background color
    LDY #2
    LDA #%11111111
    STY ENAM1
    STA GRP1                ; the pipe vertical gap never starts from the completely beginning of the visible screen, so it is safe to always draw pipes graphics for the first scanline

.GameLoop
    STA WSYNC

    STY ENAM1
    STA GRP1
    
.CheckBirdPosition:
    TXA                 
    SEC                     
    SBC BirdYPosition       ; subtract sprite Y-coordinate
    CMP #BIRD_HEIGHT        ; check if we are inside the sprite height bounds
    BCC .DrawBirdSprite     ; if result < SpriteHeight, draw the sprite
    LDA #0                  ; else, set lookup index to zero (disabe the sprite)

.DrawBirdSprite:
    TAY

    LDA BirdBitmap,Y
    STA GRP0

    LDA BirdColor,Y
    STA COLUP0

.CheckPipe1Position:
    LDA #2
    CPX Pipe1VerticalGapStartPosition
    BMI .TransferPipe1Sprite
    CPX Pipe1VerticalGapEndPosition
    BPL .TransferPipe1Sprite
    LDA #0
.TransferPipe1Sprite:
    TAY                                 ; transfer pipe 1 sprite to the Y register to apply it later in the beginning of the next scanline

.CheckPipe2Position:
    LDA #%11111111
    CPX Pipe2VerticalGapStartPosition
    BMI .Pipe2CheckEnd
    CPX Pipe2VerticalGapEndPosition
    BPL .Pipe2CheckEnd
    LDA #0
.Pipe2CheckEnd:
    DEX
    BNE .GameLoop

;; <---- Display static playfield (grass and ground) at the bottom of the screen ---->

.DrawStaticPlayfield:
    STA WSYNC
    
    LDA #%11111111
    STA PF1
    STA PF2

    LDA #0
    STA PF0

    STA COLUBK
    STA GRP1
    STA ENAM1

    LDA GrassColor
    STA COLUPF

    LDA #0
    STA GRP0

    REPEAT 5
        STA WSYNC
    REPEND

    LDA GroundColor
    STA COLUPF
    REPEAT 20
        STA WSYNC
    REPEND

    LDA #0
    STA PF0
    STA PF1
    STA PF2

;; <---- Display Overscan lines ---->

    LDA #2
    STA VBLANK          ; enable VBLANK
    REPEAT 28
        STA WSYNC       ; display 30 - 2 VBLANK overscan scanlines
    REPEND

    LDA GameState
    CMP #GAME_STATE_OVER
    BEQ EndControllerInputProcessing

    LDA BirdXPosition
.CheckIfBirdPassedPipe1:
    CMP Pipe1XPosition
    BEQ .UpdateScore
.CheckIfBirdPassedPipe2:
    CMP Pipe2XPosition
    BNE CheckControllerButtonPressed

.UpdateScore:
    SED
    LDA Score+1
    CLC
    ADC #1
    STA Score+1                   ; add 1 to the score ones and tens
    LDA Score
    ADC #0                        ; add 0 to the score hundreds and thousands, carry will add 1 if needed
    STA Score
    CLD

;; <---- Input processing ---->

CheckControllerButtonPressed:
    LDA #%10000000
    BIT INPT4
    BMI EndControllerInputProcessing
    LDY INPT4
    CPY ButtonDebounce
    BEQ EndControllerInputProcessing
.ControllerButtonPressed:
    LDA #GAME_STATE_ACTIVE
    STA GameState
    LDA #BIRD_JUMP_SPEED
    STA BirdYVelocity

EndControllerInputProcessing:
    STY ButtonDebounce

CheckResetSwitchPressed:
    LDA GameState
    CMP #GAME_STATE_OVER
    BNE EndSwitchInputProcessing
    LDA BirdYPosition
    CMP #BIRD_MIN_Y_POSITION
    BNE EndSwitchInputProcessing
    LDA SWCHB                       ; load the state of the switches into A register
    LSR                             ; shift bits to the right ; the RESET switch state (bit D0 of the SWCHB) is now in the carry
    BCS EndSwitchInputProcessing    ; if the carry (bit D0 of the SWCHB) is set, then it means that RESET swirch was not pressed
.ResetSwitchPressed:
    JSR ResetGame

EndSwitchInputProcessing:
    STA WSYNC

;; <---- Game over (bird collision) check ---->

CheckGameOver:
    LDA GameState
    CMP #GAME_STATE_OVER
    BEQ EndGameOverCheck
    LDA #%10000000
    BIT CXPPMM
    BNE .GameOver
    BIT CXM1P
    BNE .GameOver
    LDA BirdYPosition
    CMP #BIRD_MIN_Y_POSITION
    BEQ .GameOver
    JMP EndGameOverCheck
.GameOver:
    LDA #$30
    STA ScoreColor
    LDA #GAME_STATE_OVER
    STA GameState

EndGameOverCheck:
    STA WSYNC
    JMP Frame

;; <---- Lookup tables for sprites ---->

Digits:
    .byte %01110111          ; ### ###
    .byte %01010101          ; # # # #
    .byte %01010101          ; # # # #
    .byte %01010101          ; # # # #
    .byte %01110111          ; ### ###

    .byte %00010001          ;   #   #
    .byte %00010001          ;   #   #
    .byte %00010001          ;   #   #
    .byte %00010001          ;   #   #
    .byte %00010001          ;   #   #

    .byte %01110111          ; ### ###
    .byte %00010001          ;   #   #
    .byte %01110111          ; ### ###
    .byte %01000100          ; #   #
    .byte %01110111          ; ### ###

    .byte %01110111          ; ### ###
    .byte %00010001          ;   #   #
    .byte %00110011          ;  ##  ##
    .byte %00010001          ;   #   #
    .byte %01110111          ; ### ###

    .byte %01010101          ; # # # #
    .byte %01010101          ; # # # #
    .byte %01110111          ; ### ###
    .byte %00010001          ;   #   #
    .byte %00010001          ;   #   #

    .byte %01110111          ; ### ###
    .byte %01000100          ; #   #
    .byte %01110111          ; ### ###
    .byte %00010001          ;   #   #
    .byte %01110111          ; ### ###

    .byte %01110111          ; ### ###
    .byte %01000100          ; #   #
    .byte %01110111          ; ### ###
    .byte %01010101          ; # # # #
    .byte %01110111          ; ### ###

    .byte %01110111          ; ### ###
    .byte %00010001          ;   #   #
    .byte %00010001          ;   #   #
    .byte %00010001          ;   #   #
    .byte %00010001          ;   #   #

    .byte %01110111          ; ### ###
    .byte %01010101          ; # # # #
    .byte %01110111          ; ### ###
    .byte %01010101          ; # # # #
    .byte %01110111          ; ### ###

    .byte %01110111          ; ### ###
    .byte %01010101          ; # # # #
    .byte %01110111          ; ### ###
    .byte %00010001          ;   #   #
    .byte %01110111          ; ### ###

ReversedDigits:
    .byte %11101110          ;### ### 
    .byte %10101010          ;# # # # 
    .byte %10101010          ;# # # # 
    .byte %10101010          ;# # # # 
    .byte %11101110          ;### ###

    .byte %10001000          ;#   #   
    .byte %10001000          ;#   #   
    .byte %10001000          ;#   #   
    .byte %10001000          ;#   #   
    .byte %10001000          ;#   #

    .byte %11101110          ;### ### 
    .byte %10001000          ;#   #   
    .byte %11101110          ;### ### 
    .byte %00100010          ;  #   # 
    .byte %11101110          ;### ###

    .byte %11101110          ;### ### 
    .byte %10001000          ;#   #   
    .byte %11001100          ;##  ##  
    .byte %10001000          ;#   #  
    .byte %11101110          ;### ###

    .byte %10101010          ;# # # # 
    .byte %10101010          ;# # # # 
    .byte %11101110          ;### ### 
    .byte %10001000          ;#   #   
    .byte %10001000          ;#   #

    .byte %11101110          ;### ### 
    .byte %00100010          ;  #   # 
    .byte %11101110          ;### ### 
    .byte %10001000          ;#   #   
    .byte %11101110          ;### ###

    .byte %11101110          ;### ### 
    .byte %00100010          ;#   # 
    .byte %11101110          ;### ### 
    .byte %10101010          ;# # # # 
    .byte %11101110          ;### ###

    .byte %11101110          ;### ### 
    .byte %10001000          ;#   #   
    .byte %10001000          ;#   #   
    .byte %10001000          ;#   #   
    .byte %10001000          ;#   #

    .byte %11101110          ;### ### 
    .byte %10101010          ;# # # # 
    .byte %11101110          ;### ### 
    .byte %10101010          ;# # # # 
    .byte %11101110          ;### ### 

    .byte %11101110          ;### ### 
    .byte %10101010          ;# # # # 
    .byte %11101110          ;### ### 
    .byte %10001000          ;#   #   
    .byte %11101110          ;### ###

BirdBitmap:
    .byte #%00000000
    .byte #%00011000
    .byte #%00111100
    .byte #%01111111
    .byte #%01110000
    .byte #%11111111
    .byte #%11111110
    .byte #%11111110
    .byte #%01110100
    .byte #%00111100
    .byte #%00011000

BirdColor:
    .byte #$1A
    .byte #$1A
    .byte #$1A
    .byte #$1A
    .byte #$1A
    .byte #$1A
    .byte #$1A
    .byte #$1A
    .byte #$1A
    .byte #$1A
    .byte #$1A 

;; <---- Subroutines ---->

;; Subroutine to set object horizontal position with fine offset
;; The value in A register is the X coordinate to set
;; The value in Y register is the object to set the X coordinate to (0: player0, 1: player1, 2: missile0, 3: missile1, 4: ball)
SetObjectXPosition subroutine
    CMP #RIGHT_BORDER   ; when the object is beyond the right border, then it's position is set to the max possible value
    BCC .Set
    LDA #RIGHT_BORDER
.Set
    STA WSYNC           ; start a new scanline
    SEC                 ; set carry-flag before subtraction
.DivideBy15              
    SBC #15             ; subtract 15 from accumulator
    BCS .DivideBy15     ; loop until carry-flag is clear
    EOR #7              ; handle offset range from -8 to 7
    ASL                 
    ASL
    ASL
    ASL                 ; four shift lefts to get only the top 4 bits
    STA HMP0,Y          ; store the fine offset to the correct HMxx
    STA RESP0,Y         ; fix object position in 15-step increment
    RTS                 ; return from subroutine

;; Subroutine to calculate and store a new pipe position based on given X coordinate
;; The new position will be 1 unit to the left or reset to the right of the screen if the new pipe X coordinate is beyond the left border of the screen
;; If the new pipe X coordinate is reset as a result of going beyond the left border, then new random gap is generated for this pipe
;; The value in Y register is the pipe to set the new X coordinate to (0: pipe 1, 1: pipe 2)
;; The value in X register is the number of remaining VBLANK scanlines
ProcessNewPipePosition subroutine
    LDA BirdYPosition                       ; if bird has reached the ground, then it means that it doesn't move anymore, so pipes positions shouldn't be updated
    CMP #BIRD_MIN_Y_POSITION
    BEQ .CheckScanlineOverflow
    LDA Pipe1XPosition,Y
    SEC
    SBC #1
    CMP #LEFT_BORDER
    BNE .StoreNewPipeXPosition
.ResetPipeXPosition:
    JSR GenerateAndSetRandomPipeGap
    LDA #RIGHT_BORDER
    DEX                                     ; decrement remaining VBLANK scanlines count because pipes gap generation will take additional scanline
.StoreNewPipeXPosition:
    STA Pipe1XPosition,Y
.CheckScanlineOverflow:
    LDA Pipe1XPosition,Y                    ; load the pipe position again because we can jump here from the beginning of the subroutine if bird reached it's min position and in this case A register will contain bird Y position
    CMP #135                                ; SetObjectXPosition subroutine will take more than 1 scanline if position is >= 135 ; compensate that by decrementing remaining VBLANK scanlines counter
    BCC .ReturnFromGetNewPipePosition
    DEX
.ReturnFromGetNewPipePosition:
    RTS

;; Subroutine to calculate offsets for scoreboard digits to be displayed on the screen
CalculateDigitOffset subroutine
    LDY #1                  ; X register is the loop counter
.PrepareScoreLoop           ; this will loop twice, first X=1 and then X=0

    LDA Score,Y             ; load A with thousands and hundreds (Y=1) or tens and ones (Y=0)
    AND #$0F                ; remove the tens digit by masking 4 bits 00001111
    STA Temp                ; save the value of A into the Temp variable
    ASL                     ; shift left (it is now N*2)
    ASL                     ; shift left (it is now N*4)
    ADC Temp                ; add the value saved in Temp (+N)
    STA OnesDigitOffset,Y   ; save A in OnesDigitOffset+1 or OnesDigitOffset

    LDA Score,Y             ; load A with thousands and hundreds (Y=1) or tens and ones (Y=0)
    AND #$F0                ; remove the ones digit by masking 4 bits 11110000
    LSR                     ; shift right (it is now N/2)
    LSR                     ; shift right (it is now N/4)
    STA Temp                ; save the value of A into Temp
    LSR                     ; shift right (it is now N/8)
    LSR                     ; shift right (it is now N/16)
    ADC Temp                ; add the value saved in Temp (N/16+N/4)
    STA TensDigitOffset,Y   ; store A in TensDigitOffset+1 or TensDigitOffset

    DEY                     ; Y--
    BPL .PrepareScoreLoop   ; while Y >= 0, loop to pass a second time

    RTS

;; Subroutine to reset game to initial state
ResetGame subroutine
    STA CXCLR               ; clear collision registers

    LDA #55
    STA BirdXPosition

    LDA #65
    STA BirdYPosition

    LDA #$0E
    STA ScoreColor

    LDA #0
    STA BirdYVelocity

    STA Score
    STA Score+1

    STA GameState

    LDA #RIGHT_BORDER
    STA Pipe1XPosition

    LDA #200
    STA Pipe2XPosition

    LDA #1
    STA BirdYVelocity

    LDY #0
    JSR GenerateAndSetRandomPipeGap
    LDY #1
    JSR GenerateAndSetRandomPipeGap

    RTS

;; Subroutine to generate a random number by using a Linear Feedback Shift Register
;; The result will be stored in A register
GenerateRandomNumber subroutine
    LDA RandomNumber
    LSR
    BCC .NoEor
    EOR #$B4 
.NoEor:
    STA RandomNumber
    
    RTS

Sleep12Cycles subroutine
    RTS

;; Subroutine to generate random vertical gap start and end position for a pipe
;; The value in Y register is the pipe to generate random gap for (0: pipe 1, 1: pipe 2)
GenerateAndSetRandomPipeGap subroutine
    JSR GenerateRandomNumber
    AND #%00111111                          ; trim the generated number so the gap would be in bounds of a visible screen
    CLC
    ADC #20                                 ; increment generated number to eliminate the possibility of generated gap being too low
    STA Pipe1VerticalGapStartPosition,Y
    ADC #VERTICAL_GAP_BETWEEN_PIPES
    STA Pipe1VerticalGapEndPosition,Y
    RTS

;; Complete ROM size with 4KB
    ORG $FFFC           ; move to position $FFFC
    word Reset          ; write 2 bytes with the program reset address
    word Reset          ; write 2 bytes with the interruption vector